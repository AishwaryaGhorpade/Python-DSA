What is Abstraction in Python?

Abstraction means showing only the essential features of an object and hiding the internal implementation.

In Python, abstraction is mainly implemented using:

‚úÖ 1. Abstract Classes
‚úÖ 2. Abstract Methods

Python provides abstraction using the abc (Abstract Base Class) module.

üîπ Why Abstraction is Important?

Hides complex code

Increases security

Improves maintainability

Forces subclasses to implement required methods

Helps build frameworks and large applications cleanly

üîπ How to Implement Abstraction in Python

To create abstraction in Python, we use:

from abc import ABC, abstractmethod

‚úÖ Step-by-Step Implementation
Step 1: Create an abstract class
from abc import ABC, abstractmethod

class Vehicle(ABC):

    @abstractmethod
    def start(self):
        pass


Vehicle is an abstract class.

start() is an abstract method, meaning:

It has NO implementation.

Any class inheriting Vehicle MUST implement it.

Step 2: Create a subclass that implements the abstract method
class Car(Vehicle):

    def start(self):
        print("Car engine starts with a key or button.")

Step 3: Use the subclass
car = Car()
car.start()

Output:
Car engine starts with a key or button.

‚ùå What happens if you don‚Äôt implement the abstract method?
class Bike(Vehicle):
    pass

bike = Bike()  # ERROR


You will get:

TypeError: Can't instantiate abstract class Bike with abstract methods start


Python prevents object creation unless all abstract methods are implemented.
This enforces rules for all child classes.

üîπ A More Detailed Example
Abstract class for Payment
from abc import ABC, abstractmethod

class Payment(ABC):

    @abstractmethod
    def make_payment(self, amount):
        pass

    def show_receipt(self):
        print("Receipt generated.")

Subclass 1: Credit Card
class CreditCard(Payment):

    def make_payment(self, amount):
        print(f"Paid ‚Çπ{amount} using Credit Card.")

Subclass 2: UPI
class UPI(Payment):

    def make_payment(self, amount):
        print(f"Paid ‚Çπ{amount} using UPI.")

Use the classes
p1 = CreditCard()
p1.make_payment(1000)
p1.show_receipt()

p2 = UPI()
p2.make_payment(500)
p2.show_receipt()

üîπ What We Achieved with Abstraction here?

The user (developer) does not know how payment is processed.

They only use make_payment() ‚Äî the internal logic is hidden.

We ensure every payment method MUST define its own process.

Real-Life Use Cases of Abstraction
‚úî ATM machine

You only press buttons; internal operations (PIN check, network call) are hidden.

‚úî Car driving

You use steering and brakes; engine mechanics are hidden.

‚úî Mobile apps

You click "send message," while internal API calls are abstracted.

üîπ Important Points for Interview

You cannot create an object of an abstract class.

An abstract class may contain:

Abstract methods

Concrete methods (normal methods)

Subclasses must implement all abstract methods.

Abstraction improves security & flexibility.

‚≠ê Final Summary
Feature	Explanation
Abstract Class	--> Base class cannot be instantiated
Abstract Method -->	Must be implemented in child classes
Module	--> abc
Decorator -->	@abstractmethod
Purpose	--> Hide complexity and enforce rules| Feature   


Normal Method vs Abstract Method


                                    | Normal Method      | Abstract Method                              |
| ------------------------------- | ------------------ | -------------------------------------------- |
| Has implementation?             | ‚úÖ YES              | ‚ùå NO (only method name, no body)             |
| Can be used directly?           | ‚úÖ YES              | ‚ùå NO (must be overridden in subclass)        |
| Forces subclass to implement?   | ‚ùå No               | ‚úÖ Yes                                        |
| Can create object of the class? | ‚úÖ Yes              | ‚ùå No (abstract class cannot be instantiated) |
| Purpose                         | Write working code | Create a rule/contract for subclasses        |


